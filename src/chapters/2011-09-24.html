<h1>Unix time and the Ruby Time class</h1>
<p>The Unix epoch is defined as January 1, 1970, 00:00:00 UTC (Coordinated
Universal Time[1]).  Unix systems return the time in seconds as a signed
integer relative to the Unix epoch.  Negative numbers are interpreted as
dates before the Unix epoch.</p>

<p>Using seconds (and fractions of a second) to represent time allows
application authors to rely on arithmetic rather than specialized
functions for calculating time intervals.</p>

<p>File systems expose timestamps for all files in Unix time with varying
degrees of accuracy and granularity.  The Ruby File and File::Stat
classes can support timestamps with sub-second granularity on some
systems.</p>

<p>Modern kernels do not know nor care about timezones.  Conversions from
UTC to the local timezone (and vice versa) are done in user space[2].
Different processes running concurrently on the same machine do not
necessarily share the same local timezone.</p>

<h2>Ruby Time class</h2>

<p>The Ruby Time class includes methods for reading the system time and
allows converting from an Integer (seconds since the epoch) to a Ruby
Time object.</p>

<p>Ruby Time objects have a timezone attached to them, but remember
this is a user space construct.</p>

<h2>Time.now / gettimeofday(2) / clock_gettime(2)</h2>

<p>gettimeofday(2) is the commonly available system call for reading the
Unix time with (up to) microsecond resolution.  On some systems,
clock_gettime(2) may be used for nanosecond resolution[3].</p>

<p>Time.now will return the current time as a Time object taking into
account the timezone of the current process (in user space).  Ruby 1.9
may use clock_gettime(2) internally if available, but fall back to
gettimeofday(2) to retrieve the system time.</p>

<h2>Time#tv<em>sec / Time#tv</em>usec / Time#tv_nsec</h2>

<p>These accessors allow access to the underlying values returned by
gettimeofday(2) or clock<em>gettime(2) as Integers.  For systems without
nanosecond resolution, Time#tv</em>nsec may just be the value of
Time#tv_usec multiplied by 1000.</p>

<h2>Time.at - converts from Unix time to a Time object</h2>

<p>If you have the number of seconds (and maybe microseconds) as integer
seconds since the Unix epoch, you can convert that into a Ruby Time
object using the Time.at class method:</p>

<pre><code>Time.at(seconds[, microseconds ])
</code></pre>

<p>This is is useful if you encounter a Unix timestamp anywhere but want to
have a Ruby Time object.  The local timezone is attached to the created
object.</p>

<p>There is no underlying syscall needed for this, this conversion can be
performed entirely in user space (although it may require memory
allocation).</p>

<h2>Process timezone</h2>

<p>The &quot;TZ&quot; environment variable controls the timezone for a given process,
and thus the timezone attached to a Ruby Time object.  If &quot;TZ&quot; is unset,
the timezone of the process is implementation-defined.</p>

<h2>Time#utc</h2>

<p>If your process is not running under UTC, you may wish to convert
Time objects to UTC with this method.</p>

<h2>Setting system time</h2>

<p>Ruby does not provide methods to change the system time.  Changing
system time typically requires administrator (root) privileges and few
applications (especially high-level ones) need to change the system
time.  For machines with network access, system time is commonly
synchronized via NTP and gradually adjusted via adjtime(3) and/or
non-portable syscalls.</p>

<h2>Monotonic clocks</h2>

<p>Some systems support a monotonic clock which is not adjustable (even by
the administrator).  A monotonic clock is useful for maintaining
consistent timing and scheduling across system time changes.</p>

<p>Ruby currently (as of 1.9.3) does not provide access to the monotonic
clock.  However, Ruby implementations may use the monotonic clock
internally for timing (via clock_gettime(2)) and recording time
differences.</p>

<h2>Avoiding system calls</h2>

<p>You may notice the lack of gettimeofday(2) or clock<em>gettime(2) syscalls
if you're tracing syscalls.  This is because C libraries can work with
the kernel to optimize away the syscalls for gettimeofday(2) and
clock</em>gettime(2).  These implementations may trade accuracy for speed,
but may be disabled (by the administrator) if accuracy is more
important (than speed).</p>

<p>[1] - One should know UTC is not exactly the same as Greenwich Mean Time
      (GMT)</p>

<p>[2] - Timezone information is usually on (regular) files, so it may
      require syscalls to read those files.</p>

<p>[3] - You're not guaranteed this level of accuracy is supported
      by your kernel nor your hardware.  Consult your operating
      system and hardware documentation for more information.</p>

<p>License: GPLv3 (or later, at the discretion of Eric Wong)</p>

<h2>         http://www.gnu.org/licenses/gpl-3.0.txt</h2>

<p>Eric Wong</p>
